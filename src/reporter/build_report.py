"""Build report generator.

Produces ``build-report.md`` summarising the build: features implemented,
test results, coverage, known limitations, and technology stack.
"""

from __future__ import annotations

import asyncio
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from rich.console import Console

console = Console()


# ---------------------------------------------------------------------------
# BuildReportGenerator
# ---------------------------------------------------------------------------

class BuildReportGenerator:
    """Generates ``build-report.md`` with features, test results, and metadata.

    Sections:
    - Build summary (project name, date, duration)
    - Features implemented (table with status)
    - Test results summary (pass/fail counts)
    - Test coverage
    - Known limitations
    - Technology stack
    """

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    async def generate(
        self,
        features: list[dict[str, Any]],
        test_results: dict[str, Any],
        build_metadata: dict[str, Any],
        output_path: str | Path,
    ) -> Path:
        """Generate build report markdown.

        Parameters
        ----------
        features:
            List of feature dicts, each with ``name``, ``status``
            (``implemented`` | ``partial`` | ``skipped``), ``description``,
            and optionally ``priority``, ``complexity``.
        test_results:
            Dict with keys like ``total``, ``passed``, ``failed``,
            ``skipped``, ``duration_seconds``, ``coverage_percent``,
            ``suites`` (list of per-suite results).
        build_metadata:
            Dict with keys like ``project_name``, ``start_time``,
            ``end_time``, ``duration_minutes``, ``git_branch``,
            ``git_commit``, ``known_limitations``, ``technology_stack``.
        output_path:
            File path where the markdown will be written.

        Returns
        -------
        Path
            Absolute path to the written file.
        """
        output = Path(output_path).resolve()
        output.parent.mkdir(parents=True, exist_ok=True)

        content = self._render(features, test_results, build_metadata)

        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, output.write_text, content, "utf-8")

        console.print(f"[green]Build report written to {output}[/green]")
        return output

    # ------------------------------------------------------------------
    # Rendering
    # ------------------------------------------------------------------

    def _render(
        self,
        features: list[dict[str, Any]],
        test_results: dict[str, Any],
        metadata: dict[str, Any],
    ) -> str:
        """Render the complete build report markdown."""
        project_name = metadata.get("project_name", "Project")
        sections: list[str] = []

        # Header
        sections.append(f"# {project_name} -- Build Report")
        sections.append("")
        sections.append(
            f"> Generated by NC Dev System on "
            f"{datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}"
        )
        sections.append("")

        # Build summary
        sections.extend(self._render_summary(metadata))

        # Features
        sections.extend(self._render_features(features))

        # Test results
        sections.extend(self._render_test_results(test_results))

        # Test coverage
        sections.extend(self._render_coverage(test_results))

        # Known limitations
        sections.extend(self._render_limitations(metadata))

        # Technology stack
        sections.extend(self._render_tech_stack(metadata))

        # Footer
        sections.append("---")
        sections.append("")
        sections.append(
            "*This report was auto-generated by the NC Dev System. "
            "For usage instructions, see `usage-guide.md`. "
            "For API details, see `api-documentation.md`.*"
        )
        sections.append("")

        return "\n".join(sections)

    def _render_summary(self, metadata: dict[str, Any]) -> list[str]:
        """Render the build summary section."""
        lines: list[str] = []
        lines.append("## Build Summary")
        lines.append("")

        project_name = metadata.get("project_name", "N/A")
        start_time = metadata.get("start_time", "")
        end_time = metadata.get("end_time", "")
        duration = metadata.get("duration_minutes", None)
        git_branch = metadata.get("git_branch", "main")
        git_commit = metadata.get("git_commit", "N/A")

        lines.append("| Property | Value |")
        lines.append("|----------|-------|")
        lines.append(f"| **Project** | {project_name} |")

        if start_time:
            lines.append(f"| **Build Started** | {start_time} |")
        if end_time:
            lines.append(f"| **Build Completed** | {end_time} |")
        if duration is not None:
            lines.append(f"| **Duration** | {duration:.1f} minutes |")

        lines.append(f"| **Branch** | `{git_branch}` |")
        if git_commit and git_commit != "N/A":
            lines.append(f"| **Commit** | `{git_commit[:12]}` |")

        # Overall build status
        status = metadata.get("status", "completed")
        status_icon = {
            "completed": "Completed",
            "partial": "Partial (see limitations)",
            "failed": "Failed",
        }.get(status, status.title())
        lines.append(f"| **Status** | {status_icon} |")

        lines.append("")
        return lines

    def _render_features(self, features: list[dict[str, Any]]) -> list[str]:
        """Render the features implemented section."""
        lines: list[str] = []
        lines.append("## Features Implemented")
        lines.append("")

        if not features:
            lines.append("*No features recorded.*")
            lines.append("")
            return lines

        lines.append("| # | Feature | Priority | Complexity | Status |")
        lines.append("|---|---------|----------|-----------|--------|")

        status_labels = {
            "implemented": "Implemented",
            "partial": "Partial",
            "skipped": "Skipped",
            "in_progress": "In Progress",
        }

        implemented = 0
        total = len(features)

        for idx, feat in enumerate(features, start=1):
            name = feat.get("name", "Unnamed")
            priority = feat.get("priority", "P1")
            complexity = feat.get("complexity", "medium")
            status = feat.get("status", "implemented")
            label = status_labels.get(status, status.title())

            if status == "implemented":
                implemented += 1

            lines.append(
                f"| {idx} | {name} | {priority} | "
                f"{complexity.title()} | {label} |"
            )

        lines.append("")
        lines.append(
            f"**Summary:** {implemented}/{total} features fully implemented "
            f"({implemented/total*100:.0f}% completion rate)"
            if total > 0
            else "**Summary:** No features defined."
        )
        lines.append("")
        return lines

    def _render_test_results(self, test_results: dict[str, Any]) -> list[str]:
        """Render the test results section."""
        lines: list[str] = []
        lines.append("## Test Results")
        lines.append("")

        total = test_results.get("total", 0)
        passed = test_results.get("passed", 0)
        failed = test_results.get("failed", 0)
        skipped = test_results.get("skipped", 0)
        duration = test_results.get("duration_seconds", None)

        if total == 0:
            lines.append("*No test results available.*")
            lines.append("")
            return lines

        pass_rate = (passed / total * 100) if total > 0 else 0

        lines.append("### Overview")
        lines.append("")
        lines.append("| Metric | Value |")
        lines.append("|--------|-------|")
        lines.append(f"| **Total Tests** | {total} |")
        lines.append(f"| **Passed** | {passed} |")
        lines.append(f"| **Failed** | {failed} |")
        lines.append(f"| **Skipped** | {skipped} |")
        lines.append(f"| **Pass Rate** | {pass_rate:.1f}% |")
        if duration is not None:
            lines.append(f"| **Duration** | {duration:.1f}s |")
        lines.append("")

        # Per-suite breakdown
        suites = test_results.get("suites", [])
        if suites:
            lines.append("### Test Suites")
            lines.append("")
            lines.append("| Suite | Tests | Passed | Failed | Duration |")
            lines.append("|-------|-------|--------|--------|----------|")

            for suite in suites:
                suite_name = suite.get("name", "Unknown")
                suite_total = suite.get("total", 0)
                suite_passed = suite.get("passed", 0)
                suite_failed = suite.get("failed", 0)
                suite_dur = suite.get("duration_seconds", 0)
                lines.append(
                    f"| {suite_name} | {suite_total} | {suite_passed} | "
                    f"{suite_failed} | {suite_dur:.1f}s |"
                )

            lines.append("")

        # Failed test details
        failed_tests = test_results.get("failed_tests", [])
        if failed_tests:
            lines.append("### Failed Tests")
            lines.append("")
            for ft in failed_tests:
                test_name = ft.get("name", "Unknown")
                error_msg = ft.get("error", "No error message")
                lines.append(f"- **{test_name}**: {error_msg}")
            lines.append("")

        return lines

    def _render_coverage(self, test_results: dict[str, Any]) -> list[str]:
        """Render the test coverage section."""
        lines: list[str] = []
        coverage = test_results.get("coverage_percent", None)

        lines.append("## Test Coverage")
        lines.append("")

        if coverage is None:
            lines.append("*Coverage data not available.*")
            lines.append("")
            return lines

        lines.append(f"**Overall Coverage:** {coverage:.1f}%")
        lines.append("")

        target = 80
        if coverage >= target:
            lines.append(
                f"Coverage meets the target threshold of {target}%."
            )
        else:
            lines.append(
                f"**Warning:** Coverage ({coverage:.1f}%) is below the target "
                f"threshold of {target}%. Additional tests are recommended."
            )

        lines.append("")

        # Per-module coverage breakdown if available
        module_coverage = test_results.get("module_coverage", [])
        if module_coverage:
            lines.append("### Per-Module Coverage")
            lines.append("")
            lines.append("| Module | Statements | Covered | Missing | Coverage |")
            lines.append("|--------|-----------|---------|---------|----------|")
            for mod in module_coverage:
                name = mod.get("name", "unknown")
                stmts = mod.get("statements", 0)
                covered = mod.get("covered", 0)
                missing = mod.get("missing", 0)
                pct = mod.get("percent", 0.0)
                lines.append(
                    f"| `{name}` | {stmts} | {covered} | {missing} | {pct:.1f}% |"
                )
            lines.append("")

        return lines

    def _render_limitations(self, metadata: dict[str, Any]) -> list[str]:
        """Render the known limitations section."""
        lines: list[str] = []
        limitations = metadata.get("known_limitations", [])

        lines.append("## Known Limitations")
        lines.append("")

        if not limitations:
            lines.append("No known limitations at this time.")
            lines.append("")
            return lines

        for limitation in limitations:
            if isinstance(limitation, str):
                lines.append(f"- {limitation}")
            elif isinstance(limitation, dict):
                title = limitation.get("title", "Limitation")
                desc = limitation.get("description", "")
                lines.append(f"- **{title}**: {desc}")

        lines.append("")
        return lines

    def _render_tech_stack(self, metadata: dict[str, Any]) -> list[str]:
        """Render the technology stack section."""
        lines: list[str] = []
        tech_stack = metadata.get("technology_stack", None)

        lines.append("## Technology Stack")
        lines.append("")

        if tech_stack and isinstance(tech_stack, dict):
            for category, technologies in tech_stack.items():
                lines.append(f"### {category.title()}")
                lines.append("")
                if isinstance(technologies, dict):
                    lines.append("| Technology | Version/Details |")
                    lines.append("|-----------|----------------|")
                    for tech, version in technologies.items():
                        lines.append(f"| {tech} | {version} |")
                elif isinstance(technologies, list):
                    for tech in technologies:
                        lines.append(f"- {tech}")
                lines.append("")
        else:
            # Default technology stack from NC Dev System
            lines.append("### Backend")
            lines.append("")
            lines.append("| Technology | Details |")
            lines.append("|-----------|---------|")
            lines.append("| Python | 3.12+ |")
            lines.append("| FastAPI | Web framework |")
            lines.append("| MongoDB | Database (via Motor async driver) |")
            lines.append("| Pydantic v2 | Validation |")
            lines.append("| pytest | Testing |")
            lines.append("")
            lines.append("### Frontend")
            lines.append("")
            lines.append("| Technology | Details |")
            lines.append("|-----------|---------|")
            lines.append("| React 19 | UI framework |")
            lines.append("| TypeScript | Type safety (strict mode) |")
            lines.append("| Vite | Build tool |")
            lines.append("| Zustand | State management |")
            lines.append("| Axios | HTTP client |")
            lines.append("| Tailwind CSS | Styling |")
            lines.append("| Vitest | Unit testing |")
            lines.append("| Playwright | E2E testing |")
            lines.append("")
            lines.append("### Infrastructure")
            lines.append("")
            lines.append("| Technology | Details |")
            lines.append("|-----------|---------|")
            lines.append("| Docker | Containerization |")
            lines.append("| Docker Compose | Orchestration |")
            lines.append("| GitHub Actions | CI/CD |")
            lines.append("| nginx | Production frontend serving |")
            lines.append("")

        return lines
