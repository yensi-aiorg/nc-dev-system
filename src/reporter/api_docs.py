"""API documentation generator.

Produces ``api-documentation.md`` from architecture contracts, including
method, path, description, request/response examples, authentication
requirements, and rate limiting details for every endpoint.
"""

from __future__ import annotations

import asyncio
import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from rich.console import Console

console = Console()


# ---------------------------------------------------------------------------
# APIDocGenerator
# ---------------------------------------------------------------------------

class APIDocGenerator:
    """Generates ``api-documentation.md`` from architecture contracts.

    The document includes:
    - API overview and base URL
    - Authentication details
    - Per-endpoint documentation (method, path, description, request/
      response bodies with example JSON, auth requirements, rate limits)
    - Error response reference
    - Status code reference
    """

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    async def generate(
        self,
        architecture: dict[str, Any],
        output_path: str | Path,
    ) -> Path:
        """Generate API documentation markdown.

        Parameters
        ----------
        architecture:
            Architecture dict (or serialised ``Architecture`` model) with
            keys ``project_name``, ``api_contracts``, ``auth_required``,
            ``port_allocation``, ``external_apis``, etc.
        output_path:
            File path where the markdown will be written.

        Returns
        -------
        Path
            Absolute path to the written file.
        """
        output = Path(output_path).resolve()
        output.parent.mkdir(parents=True, exist_ok=True)

        content = self._render(architecture)

        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, output.write_text, content, "utf-8")

        console.print(f"[green]API documentation written to {output}[/green]")
        return output

    # ------------------------------------------------------------------
    # Rendering
    # ------------------------------------------------------------------

    def _render(self, arch: dict[str, Any]) -> str:
        """Render the full API documentation markdown."""
        project_name = arch.get("project_name", "Project")
        api_contracts = arch.get("api_contracts", [])
        auth_required = arch.get("auth_required", False)
        ports = arch.get("port_allocation", {})
        backend_port = ports.get("backend", 23001)
        external_apis = arch.get("external_apis", [])

        base_url = f"http://localhost:{backend_port}/api/v1"

        sections: list[str] = []

        # Header
        sections.append(f"# {project_name} -- API Documentation")
        sections.append("")
        sections.append(
            f"> Auto-generated by NC Dev System on "
            f"{datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}"
        )
        sections.append("")

        # Table of contents
        sections.append("## Table of Contents")
        sections.append("")
        sections.append("1. [Overview](#overview)")
        sections.append("2. [Authentication](#authentication)")
        toc_idx = 3
        for contract in api_contracts:
            label = self._contract_label(contract)
            anchor = label.lower().replace(" ", "-").replace("/", "")
            sections.append(f"{toc_idx}. [{label}](#{anchor})")
            toc_idx += 1
        sections.append(f"{toc_idx}. [Error Responses](#error-responses)")
        toc_idx += 1
        if external_apis:
            sections.append(f"{toc_idx}. [External APIs](#external-apis)")
            toc_idx += 1
        sections.append(f"{toc_idx}. [Status Codes](#status-codes)")
        sections.append("")

        # Overview
        sections.append("## Overview")
        sections.append("")
        sections.append(f"**Base URL:** `{base_url}`")
        sections.append("")
        sections.append("All endpoints return JSON responses. Request bodies (where applicable) must be JSON with `Content-Type: application/json`.")
        sections.append("")
        sections.append("### Health Check")
        sections.append("")
        sections.append("| Endpoint | Description |")
        sections.append("|----------|-------------|")
        sections.append(f"| `GET {base_url.replace('/api/v1', '')}/health` | Basic health check |")
        sections.append(f"| `GET {base_url.replace('/api/v1', '')}/ready` | Readiness check (includes DB ping) |")
        sections.append("")

        # Authentication
        sections.append("## Authentication")
        sections.append("")
        if auth_required:
            sections.append(
                "This API requires authentication via **Bearer token** in the "
                "`Authorization` header. Tokens are issued by the KeyCloak "
                "identity provider."
            )
            sections.append("")
            sections.append("```http")
            sections.append("Authorization: Bearer <access_token>")
            sections.append("```")
            sections.append("")
            sections.append(
                "To obtain a token, use the authentication endpoints below. "
                "Tokens expire after 15 minutes; use the refresh token endpoint "
                "to obtain a new access token."
            )
        else:
            sections.append(
                "This API does **not** require authentication. All endpoints "
                "are publicly accessible."
            )
        sections.append("")

        # Endpoint sections grouped by contract
        for contract in api_contracts:
            sections.extend(self._render_contract(contract, auth_required))

        # Error responses
        sections.append("## Error Responses")
        sections.append("")
        sections.append(
            "All error responses follow a consistent JSON format:"
        )
        sections.append("")
        sections.append("```json")
        sections.append(json.dumps({
            "detail": "Human-readable error message",
            "error_code": "SPECIFIC_ERROR_CODE",
            "timestamp": "2025-01-15T12:00:00Z",
        }, indent=2))
        sections.append("```")
        sections.append("")
        sections.append("### Common Error Codes")
        sections.append("")
        sections.append("| Code | HTTP Status | Description |")
        sections.append("|------|------------|-------------|")
        sections.append("| `NOT_FOUND` | 404 | Requested resource does not exist |")
        sections.append("| `VALIDATION_ERROR` | 422 | Request body failed validation |")
        sections.append("| `UNAUTHORIZED` | 401 | Missing or invalid authentication token |")
        sections.append("| `FORBIDDEN` | 403 | Authenticated but insufficient permissions |")
        sections.append("| `RATE_LIMITED` | 429 | Too many requests; retry after cooldown |")
        sections.append("| `INTERNAL_ERROR` | 500 | Unexpected server error |")
        sections.append("| `DUPLICATE_ENTRY` | 409 | Resource already exists (unique constraint) |")
        sections.append("")

        # External APIs
        if external_apis:
            sections.append("## External APIs")
            sections.append("")
            sections.append(
                "This project integrates with the following external services. "
                "In development, these are mocked via MSW (frontend) and pytest "
                "fixtures (backend). See `mock-documentation.md` for details."
            )
            sections.append("")
            for ext in external_apis:
                ext_name = ext.get("name", "Unknown") if isinstance(ext, dict) else str(ext)
                ext_url = ext.get("base_url", "") if isinstance(ext, dict) else ""
                ext_auth = ext.get("auth_type", "N/A") if isinstance(ext, dict) else "N/A"
                sections.append(f"### {ext_name}")
                sections.append("")
                if ext_url:
                    sections.append(f"- **Base URL:** `{ext_url}`")
                sections.append(f"- **Auth:** {ext_auth}")
                sections.append("")

        # Status codes
        sections.append("## Status Codes")
        sections.append("")
        sections.append("| Code | Meaning |")
        sections.append("|------|---------|")
        sections.append("| 200 | OK -- Request succeeded |")
        sections.append("| 201 | Created -- Resource created successfully |")
        sections.append("| 204 | No Content -- Resource deleted successfully |")
        sections.append("| 400 | Bad Request -- Malformed request |")
        sections.append("| 401 | Unauthorized -- Authentication required |")
        sections.append("| 403 | Forbidden -- Insufficient permissions |")
        sections.append("| 404 | Not Found -- Resource does not exist |")
        sections.append("| 409 | Conflict -- Duplicate resource |")
        sections.append("| 422 | Unprocessable Entity -- Validation failed |")
        sections.append("| 429 | Too Many Requests -- Rate limit exceeded |")
        sections.append("| 500 | Internal Server Error -- Unexpected failure |")
        sections.append("")
        sections.append("---")
        sections.append("")
        sections.append(
            f"*This documentation was auto-generated by the NC Dev System. "
            f"For usage instructions, see `usage-guide.md`.*"
        )
        sections.append("")

        return "\n".join(sections)

    def _render_contract(
        self,
        contract: dict[str, Any],
        auth_required: bool,
    ) -> list[str]:
        """Render a single API contract section."""
        lines: list[str] = []
        label = self._contract_label(contract)
        base_path = contract.get("base_path", "/api/v1")
        endpoints = contract.get("endpoints", [])

        lines.append(f"## {label}")
        lines.append("")
        lines.append(f"**Base path:** `{base_path}`")
        lines.append("")

        if not endpoints:
            lines.append("*No endpoints defined for this contract.*")
            lines.append("")
            return lines

        # Summary table
        lines.append("| Method | Path | Description | Auth |")
        lines.append("|--------|------|-------------|------|")
        for ep in endpoints:
            method = ep.get("method", "GET")
            path = ep.get("path", "/")
            desc = ep.get("description", "")
            requires = ep.get("requires_auth", auth_required)
            auth_icon = "Yes" if requires else "No"
            lines.append(f"| `{method}` | `{path}` | {desc} | {auth_icon} |")
        lines.append("")

        # Detailed endpoint docs
        for ep in endpoints:
            lines.extend(self._render_endpoint(ep, auth_required))

        return lines

    def _render_endpoint(
        self,
        ep: dict[str, Any],
        default_auth: bool,
    ) -> list[str]:
        """Render detailed documentation for a single endpoint."""
        lines: list[str] = []
        method = ep.get("method", "GET")
        path = ep.get("path", "/")
        desc = ep.get("description", "No description provided.")
        requires_auth = ep.get("requires_auth", default_auth)
        request_body = ep.get("request_body")
        response_body = ep.get("response_body", {})

        lines.append(f"### `{method} {path}`")
        lines.append("")
        lines.append(desc)
        lines.append("")

        if requires_auth:
            lines.append("**Authentication:** Required (Bearer token)")
            lines.append("")

        # Request body
        if request_body and method in ("POST", "PUT", "PATCH"):
            lines.append("**Request Body:**")
            lines.append("")
            lines.append("```json")
            example = self._generate_example(request_body)
            lines.append(json.dumps(example, indent=2))
            lines.append("```")
            lines.append("")

            # Field descriptions
            if isinstance(request_body, dict):
                field_rows = self._extract_field_descriptions(request_body)
                if field_rows:
                    lines.append("| Field | Type | Required | Description |")
                    lines.append("|-------|------|----------|-------------|")
                    for row in field_rows:
                        lines.append(
                            f"| `{row['name']}` | {row['type']} | "
                            f"{row['required']} | {row['description']} |"
                        )
                    lines.append("")

        # Response body
        if response_body:
            lines.append("**Response:**")
            lines.append("")
            lines.append("```json")
            example = self._generate_example(response_body)
            lines.append(json.dumps(example, indent=2))
            lines.append("```")
            lines.append("")

        # Rate limiting note for sensitive endpoints
        if method == "POST" and any(
            keyword in path.lower()
            for keyword in ("login", "signup", "register", "auth", "token")
        ):
            lines.append(
                "> **Rate Limiting:** This endpoint is rate-limited to "
                "5 requests per minute per IP address."
            )
            lines.append("")

        return lines

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    def _contract_label(self, contract: dict[str, Any]) -> str:
        """Generate a human-readable label for an API contract."""
        base = contract.get("base_path", "/api/v1")
        # Extract the resource name from the path
        parts = [p for p in base.strip("/").split("/") if p and p not in ("api", "v1", "v2")]
        if parts:
            return parts[-1].replace("_", " ").replace("-", " ").title()
        return "API"

    def _generate_example(self, schema: Any) -> Any:
        """Generate an example JSON value from a schema-like dict.

        Supports simple type hints (``{"field": "str"}``) and nested dicts.
        """
        if isinstance(schema, dict):
            result: dict[str, Any] = {}
            for key, value in schema.items():
                result[key] = self._generate_example(value)
            return result
        if isinstance(schema, list):
            if schema:
                return [self._generate_example(schema[0])]
            return []
        if isinstance(schema, str):
            type_examples = {
                "str": "string_value",
                "string": "string_value",
                "int": 42,
                "integer": 42,
                "float": 3.14,
                "number": 3.14,
                "bool": True,
                "boolean": True,
                "datetime": "2025-01-15T12:00:00Z",
                "date": "2025-01-15",
                "email": "user@example.com",
                "url": "https://example.com",
                "uuid": "550e8400-e29b-41d4-a716-446655440000",
                "objectid": "65a1b2c3d4e5f6a7b8c9d0e1",
            }
            lower = schema.lower().strip()
            if lower in type_examples:
                return type_examples[lower]
            # If it contains a type hint like "list[str]" or "Optional[str]"
            if "list" in lower:
                return ["item1", "item2"]
            return schema
        return schema

    def _extract_field_descriptions(
        self, schema: dict[str, Any]
    ) -> list[dict[str, str]]:
        """Extract field documentation rows from a schema dict."""
        rows: list[dict[str, str]] = []
        for key, value in schema.items():
            field_type = "object"
            required = "Yes"
            description = ""

            if isinstance(value, str):
                field_type = value
            elif isinstance(value, dict):
                field_type = "object"
                if "type" in value:
                    field_type = str(value["type"])
                if "description" in value:
                    description = str(value["description"])
                if "required" in value:
                    required = "Yes" if value["required"] else "No"
                if "default" in value:
                    required = "No"
            elif isinstance(value, list):
                field_type = "array"

            rows.append({
                "name": key,
                "type": field_type,
                "required": required,
                "description": description or f"The {key.replace('_', ' ')} field",
            })
        return rows
