# NC Dev System - Mocking System

## Mocking Philosophy

Every external dependency is mocked by default. The system runs without any real API keys.

```
External APIs identified in requirements
       │
       ├──→ Frontend: MSW (Mock Service Worker) handlers
       ├──→ Backend: pytest fixtures + httpx mock transport
       ├──→ Test data: Generated by local Ollama models
       └──→ Environment switching: MOCK_APIS=true/false
```

## Architecture

```
┌──────────────────────────────────────────────────┐
│                  MOCK LAYER                       │
│                                                   │
│  ┌─────────────────────────────────────────────┐  │
│  │  FRONTEND (MSW - Mock Service Worker)       │  │
│  │                                             │  │
│  │  Browser ──→ MSW Service Worker ──→ Mock    │  │
│  │                      │                      │  │
│  │                      └── Intercepts fetch() │  │
│  │                          Returns mock data  │  │
│  └─────────────────────────────────────────────┘  │
│                                                   │
│  ┌─────────────────────────────────────────────┐  │
│  │  BACKEND (httpx mock + pytest fixtures)     │  │
│  │                                             │  │
│  │  Service ──→ httpx.AsyncClient ──→ Mock     │  │
│  │                      │                      │  │
│  │                      └── MockTransport      │  │
│  │                          Returns fixtures   │  │
│  └─────────────────────────────────────────────┘  │
│                                                   │
│  ┌─────────────────────────────────────────────┐  │
│  │  DATA LAYER (Factory + Ollama)              │  │
│  │                                             │  │
│  │  Factory functions generate realistic data  │  │
│  │  Ollama models create domain-specific data  │  │
│  │  Seed scripts populate MongoDB with mocks   │  │
│  └─────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────┘
```

## Frontend Mocking (MSW)

### Setup

```typescript
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw'

// Auto-generated from architecture.json API contracts
export const handlers = [
  // Auth endpoints
  http.post('/api/auth/login', async ({ request }) => {
    const body = await request.json() as { email: string; password: string }
    if (body.email === 'test@example.com') {
      return HttpResponse.json({
        token: 'mock-jwt-token',
        user: { id: '1', name: 'Test User', email: body.email }
      })
    }
    return HttpResponse.json(
      { error: 'Invalid credentials' },
      { status: 401 }
    )
  }),

  // CRUD endpoints
  http.get('/api/users', () => {
    return HttpResponse.json({
      users: mockUsers,     // From factory
      total: 20,
      page: 1,
      per_page: 10
    })
  }),

  http.get('/api/users/:id', ({ params }) => {
    const user = mockUsers.find(u => u.id === params.id)
    if (!user) {
      return HttpResponse.json({ error: 'Not found' }, { status: 404 })
    }
    return HttpResponse.json(user)
  }),

  // External API mocks (e.g., Stripe)
  http.post('https://api.stripe.com/v1/charges', () => {
    return HttpResponse.json({
      id: 'ch_mock_123',
      amount: 2000,
      currency: 'usd',
      status: 'succeeded'
    })
  }),
]
```

### MSW Browser Setup

```typescript
// src/mocks/browser.ts
import { setupWorker } from 'msw/browser'
import { handlers } from './handlers'

export const worker = setupWorker(...handlers)

// src/main.tsx
async function enableMocking() {
  if (import.meta.env.VITE_MOCK_APIS !== 'true') return
  const { worker } = await import('./mocks/browser')
  return worker.start({ onUnhandledRequest: 'warn' })
}

enableMocking().then(() => {
  createRoot(document.getElementById('root')!).render(<App />)
})
```

### MSW Test Setup

```typescript
// src/mocks/server.ts
import { setupServer } from 'msw/node'
import { handlers } from './handlers'

export const server = setupServer(...handlers)

// vitest.setup.ts
import { beforeAll, afterEach, afterAll } from 'vitest'
import { server } from './src/mocks/server'

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

## Backend Mocking

### External API Client Abstraction

```python
# app/services/external/base.py
from abc import ABC, abstractmethod
from typing import Any

class ExternalAPIClient(ABC):
    """Base class for all external API clients. Supports mock mode."""

    def __init__(self, mock_mode: bool = False):
        self.mock_mode = mock_mode

    @abstractmethod
    async def call(self, endpoint: str, **kwargs) -> Any:
        pass

# app/services/external/stripe_client.py
import httpx
from app.config import settings

class StripeClient(ExternalAPIClient):
    def __init__(self):
        super().__init__(mock_mode=settings.MOCK_APIS)
        self.base_url = "https://api.stripe.com/v1"
        self.api_key = settings.STRIPE_API_KEY

    async def call(self, endpoint: str, **kwargs) -> dict:
        if self.mock_mode:
            return self._mock_response(endpoint, **kwargs)

        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{self.base_url}/{endpoint}",
                headers={"Authorization": f"Bearer {self.api_key}"},
                **kwargs
            )
            return response.json()

    def _mock_response(self, endpoint: str, **kwargs) -> dict:
        """Return mock response based on endpoint."""
        mocks = {
            "charges": {
                "id": "ch_mock_123",
                "amount": kwargs.get("data", {}).get("amount", 2000),
                "currency": "usd",
                "status": "succeeded",
                "created": 1700000000
            },
            "customers": {
                "id": "cus_mock_456",
                "email": "test@example.com",
                "name": "Test Customer"
            }
        }
        return mocks.get(endpoint, {"error": "Unknown mock endpoint"})
```

### pytest Fixtures

```python
# tests/conftest.py
import pytest
from unittest.mock import AsyncMock, patch
from app.main import app
from httpx import AsyncClient

@pytest.fixture
def mock_stripe():
    """Mock Stripe API calls."""
    with patch("app.services.external.stripe_client.StripeClient.call") as mock:
        mock.return_value = {
            "id": "ch_mock_123",
            "status": "succeeded",
            "amount": 2000
        }
        yield mock

@pytest.fixture
def mock_sendgrid():
    """Mock SendGrid email API."""
    with patch("app.services.external.email_client.EmailClient.send") as mock:
        mock.return_value = {"status": "sent", "message_id": "msg_mock_789"}
        yield mock

@pytest.fixture
async def mock_db():
    """Mock MongoDB with in-memory data."""
    from mongomock_motor import AsyncMongoMockClient
    client = AsyncMongoMockClient()
    db = client["test_db"]

    # Seed with factory data
    from tests.factories import UserFactory, ProjectFactory
    users = [UserFactory.build() for _ in range(10)]
    await db.users.insert_many([u.dict() for u in users])

    yield db

@pytest.fixture
async def client(mock_db):
    """HTTP client with mocked dependencies."""
    app.state.db = mock_db
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
```

## Data Factories (Test Data Generation)

### Factory Pattern

```python
# tests/factories.py
from datetime import datetime, timedelta
from uuid import uuid4
import random
from pydantic import BaseModel

class UserFactory:
    """Generate realistic user test data."""

    FIRST_NAMES = ["Emma", "Liam", "Olivia", "Noah", "Ava", "Sophia", "Jackson", "Mia"]
    LAST_NAMES = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller"]
    DOMAINS = ["gmail.com", "yahoo.com", "outlook.com", "company.com"]
    ROLES = ["admin", "user", "editor", "viewer"]

    @classmethod
    def build(cls, **overrides) -> dict:
        first = random.choice(cls.FIRST_NAMES)
        last = random.choice(cls.LAST_NAMES)
        return {
            "id": str(uuid4()),
            "name": f"{first} {last}",
            "email": f"{first.lower()}.{last.lower()}@{random.choice(cls.DOMAINS)}",
            "avatar_url": f"https://i.pravatar.cc/150?u={uuid4()}",
            "role": random.choice(cls.ROLES),
            "created_at": datetime.now() - timedelta(days=random.randint(1, 365)),
            "last_login": datetime.now() - timedelta(hours=random.randint(1, 72)),
            "is_active": random.random() > 0.1,
            **overrides
        }

    @classmethod
    def build_batch(cls, count: int, **overrides) -> list[dict]:
        return [cls.build(**overrides) for _ in range(count)]


class ProjectFactory:
    """Generate realistic project test data."""

    ADJECTIVES = ["Smart", "Cloud", "AI-Powered", "Modern", "Next-Gen", "Digital"]
    NOUNS = ["Dashboard", "Platform", "Analytics", "Manager", "Tracker", "Suite"]
    STATUSES = ["active", "planning", "completed", "on_hold"]

    @classmethod
    def build(cls, **overrides) -> dict:
        return {
            "id": str(uuid4()),
            "name": f"{random.choice(cls.ADJECTIVES)} {random.choice(cls.NOUNS)}",
            "description": f"A {random.choice(cls.ADJECTIVES).lower()} solution for modern teams.",
            "status": random.choice(cls.STATUSES),
            "created_at": datetime.now() - timedelta(days=random.randint(1, 180)),
            "owner_id": str(uuid4()),
            "budget": random.randint(5000, 100000),
            **overrides
        }
```

### Ollama-Powered Data Generation

For domain-specific data that factories can't easily produce:

```python
# tests/ollama_fixtures.py
"""Generate domain-specific test data using local Ollama models."""
import json
import httpx

OLLAMA_URL = "http://localhost:11434/api/generate"

async def generate_domain_data(
    entity_type: str,
    count: int,
    schema: dict,
    domain_context: str,
    model: str = "qwen3-coder:30b"  # Smaller model for speed
) -> list[dict]:
    """Generate realistic domain-specific test data using Ollama."""

    prompt = f"""Generate {count} realistic {entity_type} records as a JSON array.

Domain context: {domain_context}

Each record must follow this schema:
{json.dumps(schema, indent=2)}

Requirements:
- Use realistic, diverse data (not generic "test" values)
- Vary the data across records (different names, amounts, dates)
- Include edge cases: empty strings where optional, null values, boundary numbers
- Make dates within the last 2 years
- Make amounts/numbers realistic for the domain

Return ONLY the JSON array, no explanation."""

    async with httpx.AsyncClient(timeout=120.0) as client:
        response = await client.post(OLLAMA_URL, json={
            "model": model,
            "prompt": prompt,
            "stream": False,
            "format": "json"
        })

    return json.loads(response.json()["response"])


# Usage example:
# medical_records = await generate_domain_data(
#     entity_type="medical appointment",
#     count=20,
#     schema={
#         "patient_name": "string",
#         "doctor_name": "string",
#         "specialty": "string",
#         "date": "ISO date",
#         "duration_minutes": "integer",
#         "status": "scheduled|completed|cancelled|no_show",
#         "notes": "string or null"
#     },
#     domain_context="A healthcare scheduling platform for clinics"
# )
```

### Bulk Data Seeding Script

```python
# scripts/seed_mock_data.py
"""Seed MongoDB with mock data for development and testing."""
import asyncio
from motor.motor_asyncio import AsyncIOMotorClient
from tests.factories import UserFactory, ProjectFactory
from tests.ollama_fixtures import generate_domain_data

async def seed():
    client = AsyncIOMotorClient("mongodb://localhost:23002")
    db = client["app_dev"]

    # Factory-generated base data
    print("Generating users...")
    users = UserFactory.build_batch(50)
    await db.users.insert_many(users)

    print("Generating projects...")
    projects = ProjectFactory.build_batch(20, owner_id=users[0]["id"])
    await db.projects.insert_many(projects)

    # Ollama-generated domain-specific data
    if check_ollama_available():
        print("Generating domain-specific data via Ollama...")
        # Example for a financial app
        transactions = await generate_domain_data(
            entity_type="financial transaction",
            count=100,
            schema={
                "id": "uuid",
                "amount": "float",
                "currency": "USD/EUR/GBP",
                "type": "credit/debit",
                "category": "string",
                "merchant": "string",
                "date": "ISO date",
                "status": "completed/pending/failed"
            },
            domain_context="Personal finance tracking application",
            model="qwen3:8b"  # Fast model for bulk generation
        )
        await db.transactions.insert_many(transactions)

    print(f"Seeded: {len(users)} users, {len(projects)} projects")

def check_ollama_available():
    import httpx
    try:
        httpx.get("http://localhost:11434/api/tags", timeout=5.0)
        return True
    except Exception:
        return False

asyncio.run(seed())
```

## Environment Switching

```bash
# .env.example

# Mock mode (default: true for dev/test)
MOCK_APIS=true

# When MOCK_APIS=false, these are required:
STRIPE_API_KEY=
SENDGRID_API_KEY=
TWILIO_ACCOUNT_SID=
TWILIO_AUTH_TOKEN=
GOOGLE_MAPS_API_KEY=

# Always available (internal services)
MONGODB_URI=mongodb://localhost:23002/app
REDIS_URL=redis://localhost:23003
OLLAMA_URL=http://localhost:11434
```

```python
# app/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    MOCK_APIS: bool = True

    # External API keys (only needed when MOCK_APIS=False)
    STRIPE_API_KEY: str = "sk_mock_key"
    SENDGRID_API_KEY: str = "SG.mock_key"

    # Internal services (always available)
    MONGODB_URI: str = "mongodb://localhost:23002/app"
    REDIS_URL: str = "redis://localhost:23003"
    OLLAMA_URL: str = "http://localhost:11434"

    class Config:
        env_file = ".env"

settings = Settings()
```

## Mock Documentation Generation

The Mock Generator agent produces documentation for every mocked API:

```markdown
# Mock API Documentation

## Stripe API

### Mocked Endpoints

| Endpoint | Method | Mock Behavior |
|----------|--------|--------------|
| `/v1/charges` | POST | Returns successful charge (amount from request) |
| `/v1/charges/:id` | GET | Returns charge details |
| `/v1/customers` | POST | Returns new customer |
| `/v1/customers/:id` | GET | Returns customer details |

### Mock Responses

#### POST /v1/charges
```json
{
  "id": "ch_mock_123",
  "amount": 2000,
  "currency": "usd",
  "status": "succeeded"
}
```

### Error Scenarios
- Invalid amount (< 0): Returns 400
- Missing required fields: Returns 422
- Rate limit simulation: Returns 429 (1 in 100 requests in test mode)

### Switching to Real API
Set `MOCK_APIS=false` and provide `STRIPE_API_KEY` in `.env`
```

This documentation is auto-generated and included in the delivery package.
